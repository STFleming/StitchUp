Determining the high-level control-flow structure from a RTL description
of a circuit would be difficult both automatically and manually.
Extracting from a high level input source manually is easier but it would
be challenging for larger designs, however it can be automated by
transforming the input into a control and data flow graph (CDFG).
StitchUp can automatically perform this extraction as a compiler flag
for the LegUp HLS tool.
This section discusses the analysis for the automatic extraction of the
control-flow structure along with the generation of the protected circuit. 

\begin{figure}[t]
\centering
\includegraphics[width=3.5in]{./imgs/tool-flow.pdf}
\caption{Tool Flow Overview diagram}
\label{fig:tool_flow_diagram}
\end{figure}

%Flow Overview?
Figure \ref{fig:tool_flow_diagram} shows the transformation process for a C program
to a control-flow protected
Verilog hardware description, with StitchUp specific sections highlighted in grey.
Initially the C input is passed into the LegUp frontend which is
a series of passes that
perform various tasks, such as annotating instructions with pipelining information.
This outputs an LLVM intermediate representation (LLVM-IR) which is passed both into the backend of LegUp,
to generate the
original unprotected circuit, and into the frontend of StitchUp to generate a circuit
consisting of just the control-flow structure.
Finally an integration stage connects the original circuit to the duplicate control-flow circuit
and generates comparison logic to ensure that the state registers match.

%Why LegUp?
Our motivation for integrating our tool with LegUp is primarily due to it being open source as
the StitchUp backend requires modification to the generation of the scheduling control FSMs,
which would not be possible in a closed source tool such as VivadoHLS.
It is common for modern HLS tool to be constructed on top of LLVM-IR which has
a similar level of abstraction to assembly code.
It also has two important features for writing compiler optimisations:
firstly all instructions are in single static assignment form (SSA) where every variable is only
assigned once; and secondly instructions are grouped into straight-line sequences known as basic blocks (BB)
where there is only one entry branch at the very start of the block, and one exit branch at the very end.

\begin{figure}[t]
\centering
\includegraphics[width=3.5in]{./imgs/dot_product_cdfg.pdf}
\caption{Control-Data-Flow Diagram for Matrix Multiplication example}
\label{fig:mmm_cdfg}
\end{figure}

\subsection{Extracting the Control Instruction Set}
LLVM-IR, which is passed into the frontend of StitchUp, is naturally arranged into a CDFG
where each node is a basic block and edges are branch between them.
An example of the CDFG for the dot product in listing \ref{lst:DotProduct}
is shown on the left side of Figure \ref{fig:mmm_cdfg}.
The StitchUp frontend walks this CDFG in a backwards fashion collecting any control flow
related instructions that may have any effect any edge transition.

All instructions deemed to be control related are collected into what we refer to as a Control Structure Instruction Set ($CSIS$),
which can be used to generate a control-flow structure only circuit.
Each basic block, $i$, in the input CDFG will have it's own associated $CSIS_{i}$ containing all instructions that may effect
control-flow after this point in the program.
The overall $CSIS$ for the input is $CSIS_s$ where $s$ is the initial basic block or the input, or starting node of the CDFG.

Algorithm \ref{alg:CSIS-extraction} is used to construct the $CSIS$ for all nodes in the CDFG.
It requires a fixed point iterating until the set of all $CSIS$, $C_{CSIS}$ has reached a stable state
which can be seen in line 1-2.
Each iteration walks backwards from the final node of the CDFG to the starting one, as seen in
line 3, and for each node the corresponding $CSIS$ is updated using the following that are
labelled in the algorithm:

%\vspace{-4pt}
\begin{enumerate}
    \setlength{\itemsep}{3pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}
    \item $Sucessor(B)$ returns the set of all the nodes in the CDFG that follow on from the basic block $B$.
	  For all successor nodes, $j$, of $i$ this rule adds every element of $CSIS_j$ to $CSIS_i$.
    \item This adds all branch instructions for the current node, $i$, to $CSIS_i$ using the function
	  $TerminatingInstruction(B)$ which returns the final instruction from the basic block $B$.
    \item Finally any instruction within the current node, $i$, that is used as an operand, $op_{c}$, by an element of $CSIS_i$ is added to $CSIS_i$
\end{enumerate}
\vspace{-4pt}

\begin{algorithm}[t]
\caption{CSIS Extraction Static Analysis Algorithm
\label{alg:CSIS-extraction}}
    \begin{algorithmic}[1]
        \INPUT a program, $P$, which is a set of Basic Blocks, \{$BB_0$, ..., $BB_N$\}
        \OUTPUT $P'$ a program containing only the instructions $I_c$ that are part of the control structure.
        \Statex
        \While{$C_{CSIS}$ != $P_{CSIS}$}
            \State $P_{CSIS} \gets \{CSIS_{BB0}, \dots,  CSIS_{BBN}$\}
            \For{\textbf{each} $B \in \{BB_{N},\dots,BB_{0}\}$}
                \\\hrulefill
                \For{\textbf{each} $S \in Successor(B)$}\Comment{Rule 1}
                    \For{\textbf{each} $I_{c} \in CSIS_{S}$}
                        \State $CSIS_B \cup \{I_{c}\}$
                    \EndFor
                \EndFor
                \\\hrulefill

                \State $T \in TerminatingInstruction(B)$\Comment{Rule 2}
                \State $CSIS_{B} \cup \{T\}$
                \For{\textbf{each} $op \in T$}
                    \State $CSIS_{B} \cup \{op\}$
                \EndFor
                \\\hrulefill

                \For{\textbf{each} $I \in B$}\Comment{Rule 3}
                    \For{\textbf{each} $I_c \in CSIS_{B}$}
                        \For{\textbf{each} $op_c \in I_c$}
                            \If{$I = op_{c}$}
                                \State $CSIS_{B} \cup \{I\}$
                            \EndIf
                        \EndFor
                    \EndFor
                \EndFor
            \EndFor
	\State $P' \gets CSIS_{BB0}$
        \EndWhile
    \end{algorithmic}
\end{algorithm}

To demonstrate this we will apply Algorithm \ref{alg:CSIS-extraction} to the
dot product example in \ref{lst:DotProduct} to extract the control-flow structure, 
labelled StitchUp in \ref{fig:mmm_cdfg}. 
For each update to a $CSIS$, the label for the instruction added from \ref{fig:mmm_cdfg} is given 
along with the rule from Algorithm \ref{alg:CSIS-extraction} used to add it. 

%-------------------------------------------------------
\vspace{1mm}
\noindent
\textbf{Initially} $CSIS_{i} = \emptyset$ for all basic blocks $i$

\vspace{-2mm}
\noindent
\hrulefill

\vspace{-1mm}
\noindent
\textbf{Iteration 1:}

%----BB2----
\FirstAnalysisTraceRule{BB2}{I2.0:\textbf{return}}{2}
\CSISState{BB2}{I2.0}
%----BB1----
\FirstAnalysisTraceRule{BB1}{every element in $CSIS_{BB2}$}{1}
\AnalysisTraceRule{I1.2:\textbf{br i<20 BB2}}{2}
\AnalysisTraceRule{I1.1:\textbf{i++}}{3}
\CSISState{BB1}{I2.0,I1.2,I1.1}
%----BB0----
\FirstAnalysisTraceRule{BB0}{every element in $CSIS_{BB1}$}{1}
\AnalysisTraceRule{I0.1:\textbf{br BB1}}{2}
\AnalysisTraceRule{I0.0:\textbf{i=0}}{3}
\CSISState{BB0}{I2.0,I1.2,I1.1,I0.1,I0.0}

\vspace{1mm}
\noindent
\textbf{Iteration 2:}\hspace{3mm} No Change, fixed point reached
%-----------------------------------------------------

\vspace{1mm}


Once the analysis is completed the final value of $CSIS_{BB0}$ is turned into LLVM-IR
and given to the StitchUp backend.
Here scheduling information from the original unmodified LegUp flow is used to generate
an identical control FSM to the original circuit and insert state lost scheduling states
due to instructions being removed. 
Finally an integration stage take the original LegUp and StitchUp circuits expose their FSM state registers
along with comparison logic to compare them every clock cycle, and generates a top level wrapper to connect them.
