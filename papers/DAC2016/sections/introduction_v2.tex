\providecommand*{\lstnumberautorefname}{line}

High-level Synthesis (HLS) tools, such as LegUp \cite{canis2011legup} and Vivado HLS \cite{feist2012vivado},
can automatically generate FPGA circuits from C code.
Listing 1 gives a simple example of a synthesisable dot-product, which combines
data-dependent control-flow in the for loop (line 3), and pure data-flow
in the body of the for loop (line 5).
HLS tools will generate a circuit which executes correctly in a reliable FPGA, but what if
this circuit is required to execute in the presence of soft errors?
The naive approach would be to instantiate two or more copies of the circuit and run
them in lock-step on the same input data, with any deviations between their states or outputs
indicating an error.
Naive replication is expensive in both area and more importantly
power, especially in this example as expensive floating point arithmetic
units are required for the multiply accumulate computation (line 5).

 \lstset{
         basicstyle=\footnotesize\ttfamily, % Standardschrift
         numbers=left,               % Ort der Zeilennummern
         numberstyle=\tiny,          % Stil der Zeilennummern
	 language=C,
         %stepnumber=2,               % Abstand zwischen den Zeilennummern
         numbersep=5pt,              % Abstand der Nummern zum Text
         tabsize=2,                  % Groesse von Tabs
         extendedchars=true,         %
         breaklines=true,            % Zeilen werden Umgebrochen
         keywordstyle=\color{blue},
         %frame=b,         
 %        keywordstyle=[1]\textbf,    % Stil der Keywords
 %        keywordstyle=[2]\textbf,    %
 %        keywordstyle=[3]\textbf,    %
 %        keywordstyle=[4]\textbf,   \sqrt{\sqrt{}} %
         stringstyle=\color{white}\ttfamily, % Farbe der String
         showspaces=false,           % Leerzeichen anzeigen ?
         showtabs=false,             % Tabs anzeigen ?
         %xleftmargin=10pt,
         %framexleftmargin=17pt,
         %framexrightmargin=5pt,
         %framexbottommargin=4pt,
         %backgroundcolor=\color{lightgray},
         showstringspaces=false      % Leerzeichen in Strings anzeigen ?        
 }

When tight area and power constraints prevent full replication, then reliability can still be
improved through selectively replicating ``important" portions of the design.
Studies has shown that some applications, such as media processing
\cite{liu2012flikker} and machine learning \cite{wong2006soft}, contain critical regions
of code that are sensitive to soft errors,
and non critical regions that can tolerate soft errors.

%What about just the control flow?
Control-flow regions, (i.e. instructions effecting branch decisions), are arguably more critical
than data-flow, since faults within control-flow can effect real time guarantees
or prevent program termination.
Previous work has demonstrated this,
with \cite{chen2014reliability,chen2015reliability} generating reliable HLS circuits
for control-flow intensive (CFI) ASIC designs,
and \cite{saggese2005microprocessor, nakka2007processor, wong2006soft}
performing fault injection experiments demonstrating that control-flow is
vulnerable to errors.

%In our example what would control flow errors do?
For example, faults within the control structure of our dot product example (Listing \ref{lst:DotProduct})
could cause elements of \lstinline$A$ and \lstinline$B$ to be skipped in the
calculation of \lstinline$c$,
or even worse, cause the circuit to enter an infinite loop and never terminate.
This paper presents an approach for automatically extracting the control flow structure
for a HLS application so that it can be selectively
replicated to protect control decisions and ensure all branches are taken correctly.

\begin{figure}[t]
\begin{lstlisting}[label={lst:DotProduct}, captionpos=b, caption={Dot Product Example}]
float DotProduct(float A[20],float B[20])
{ float c = 0.0;
  for(int i=0; i<20; i++)
    c += A[i]*B[i];
  return c;
}
\end{lstlisting}
\vspace{-7mm}
\end{figure}

Figure \ref{fig:HLSArch}(a) provides a diagram of the default HLS generated
circuit for our dot product example.
Two clear partitions can be seen, a data path where functional units reside, and a
control FSM responsible for scheduling instructions onto the functional units.
In order to replicate only the control-flow structure,
any data-path functional units which may influence a state transition need to be
duplicated along with the control FSM.
We shall refer to the collection of the control FSM and control dependent data-path elements as
the \emph{control replicant}, Figure \ref{fig:HLSArch}(b) shows the control replicant for our dot product example.

Analysing the code in Listing \ref{lst:DotProduct} we can determine that the instructions
which influence control-flow decisions are the ones used in the \lstinline{for} loop
conditions, which require an integer comparator \textbf{icmp} and adder \textbf{iadd}.
In comparison, the expensive floating point units, \textbf{fpmul} and \textbf{fpadd}, required
for calculating the multiply add accumulate have no
influence over any branch decision and will not be replicated.

Manually inspecting code and removing elements that don't influence control flow
is simple in the case of our dot product example.
However as the complexity of the input increases,
the engineering effort required to both analyse the input code and generate
the replicated control FSM is significant.
StitchUp fully automates this process through using a static analysis technique, known as program slicing, to extract
and duplicate any instructions that may influence control. The contribution of this paper are:

\vspace{-10pt}
\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item StitchUp, an approach for decoupling control-flow and data-flow to increase circuit relability which has been implemented as
          an open source LegUp HLS pass that can automatically extract and protect the control flow structure of a circuit.
	\item Detailed resource and power results for StitchUp using the popular CHStone HLS benchmark.
    \item Exhaustive hardware fault injection, where every essential configuration bit is flipped to assess how well StitchUp can catch errors.
\end{itemize}
%\vspace{1mm}
%\noindent
%$\bullet$ StitchUp, a tool which can automatically extract and protect the control flow structure of a circuit generated with a HLS tool.
%
%\vspace{1mm}
%\noindent
%$\bullet$ Detailed results of StitchUp on the CHStone benchmark, where exhaustive hardware fault injection is performed on the majority of cases.
%
%\vspace{1mm}
%\noindent
%$\bullet$ Results exploring the reliability of StitchUp protected circuits as the control to data ratio is varied through loop unrolling in the matrix multiplication example.
